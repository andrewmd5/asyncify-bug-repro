{
  "version": 3,
  "sources": ["../src/wasi/abi.ts", "../src/wasi/features/fd.ts", "../src/wasi/features/args.ts", "../src/wasi/features/clock.ts", "../src/wasi/features/environ.ts", "../src/wasi/features/random.ts", "../src/wasi/index.ts", "../node_modules/asyncify-wasm/dist/asyncify.mjs", "../src/index.ts"],
  "sourcesContent": ["export class WASIAbi {\n    /**\n     * No error occurred. System call completed successfully.\n     */\n    static readonly WASI_ESUCCESS = 0;\n\n    /**\n     * Bad file descriptor.\n     */\n    static readonly WASI_ERRNO_BADF = 8;\n\n    static readonly WASI_ERRNO_ISDIR = 31;\n    static readonly WASI_ERRNO_INVAL = 28;\n\n    static readonly WASI_ERRNO_NOTDIR = 54;\n    static readonly WASI_ERRNO_NOENT = 44;\n    static readonly WASI_ERRNO_EXIST = 20;\n    static readonly WASI_ERRNO_IO = 29;\n\n    /**\n     * Function not supported.\n     */\n    static readonly WASI_ENOSYS = 52;\n\n    /**\n     * The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z.\n     */\n    static readonly WASI_CLOCK_REALTIME = 0;\n    /**\n     * The store-wide monotonic clock, which is defined as a clock measuring real time,\n     * whose value cannot be adjusted and which cannot have negative clock jumps.\n     * The epoch of this clock is undefined. The absolute time value of this clock therefore has no meaning.\n     */\n    static readonly WASI_CLOCK_MONOTONIC = 1;\n\n\n    static readonly WASI_FILETYPE_BLOCK_DEVICE = 1;\n\n    /**\n     * The file descriptor or file refers to a character device inode.\n     */\n    static readonly WASI_FILETYPE_CHARACTER_DEVICE = 2;\n\n\n    static readonly WASI_FILETYPE_DIRECTORY = 3;\n\n    static readonly WASI_FILETYPE_REGULARFILE = 4;\n\n    static readonly IMPORT_FUNCTIONS = [\n        \"args_get\",\n        \"args_sizes_get\",\n\n        \"clock_res_get\",\n        \"clock_time_get\",\n\n        \"environ_get\",\n        \"environ_sizes_get\",\n\n        \"fd_advise\",\n        \"fd_allocate\",\n        \"fd_close\",\n        \"fd_datasync\",\n        \"fd_fdstat_get\",\n        \"fd_fdstat_set_flags\",\n        \"fd_fdstat_set_rights\",\n        \"fd_filestat_get\",\n        \"fd_filestat_set_size\",\n        \"fd_filestat_set_times\",\n        \"fd_pread\",\n        \"fd_prestat_dir_name\",\n        \"fd_prestat_get\",\n        \"fd_pwrite\",\n        \"fd_read\",\n        \"fd_readdir\",\n        \"fd_renumber\",\n        \"fd_seek\",\n        \"fd_sync\",\n        \"fd_tell\",\n        \"fd_write\",\n\n        \"path_create_directory\",\n        \"path_filestat_get\",\n        \"path_filestat_set_times\",\n        \"path_link\",\n        \"path_open\",\n        \"path_readlink\",\n        \"path_remove_directory\",\n        \"path_rename\",\n        \"path_symlink\",\n        \"path_unlink_file\",\n\n        \"poll_oneoff\",\n\n        \"proc_exit\",\n        \"proc_raise\",\n\n        \"random_get\",\n\n        \"sched_yield\",\n\n        \"sock_accept\",\n        \"sock_recv\",\n        \"sock_send\",\n        \"sock_shutdown\",\n    ];\n\n    private encoder: TextEncoder;\n   \n\n    constructor() {\n        this.encoder = new TextEncoder();\n    }\n\n    writeString(memory: DataView, value: string, offset: number): number {\n        const bytes = this.encoder.encode(value);\n        const buffer = new Uint8Array(memory.buffer, offset, bytes.length);\n        buffer.set(bytes);\n        return bytes.length;\n    }\n    byteLength(value: string): number {\n        return this.encoder.encode(value).length;\n    }\n\n\n    private static readonly iovec_t = {\n        size: 8,\n        bufferOffset: 0,\n        lengthOffset: 4,\n    };\n\n    iovViews(memory: DataView, iovs: number, iovsLen: number): Uint8Array[] {\n        const iovsBuffers: Uint8Array[] = [];\n        let iovsOffset = iovs;\n\n        for (let i = 0; i < iovsLen; i++) {\n            const offset = memory.getUint32(iovsOffset + WASIAbi.iovec_t.bufferOffset, true);\n            const len = memory.getUint32(iovsOffset + WASIAbi.iovec_t.lengthOffset, true);\n\n            iovsBuffers.push(new Uint8Array(memory.buffer, offset, len));\n            iovsOffset += WASIAbi.iovec_t.size;\n        }\n        return iovsBuffers;\n    }\n\n    writeFilestat(memory: DataView, ptr: number, filetype: number): void {\n        memory.setBigUint64(ptr, /* dev */ BigInt(0), true);\n        memory.setBigUint64(ptr + 8, /* ino */ BigInt(0), true);\n        memory.setUint8(ptr + 16, filetype);\n        memory.setUint32(ptr + 24, /* nlink */ 0, true);\n        memory.setBigUint64(ptr + 32, /* size */ BigInt(0), true);\n        memory.setBigUint64(ptr + 40, /* atim */ BigInt(0), true);\n        memory.setBigUint64(ptr + 48, /* mtim */ BigInt(0), true);\n    }\n\n    writeFdstat(memory: DataView, ptr: number, filetype: number, flags: number): void {\n        memory.setUint8(ptr, filetype);\n        memory.setUint16(ptr + 2, flags, true);\n        memory.setBigUint64(ptr + 8, /* rights_base */ BigInt(0), true);\n        memory.setBigUint64(ptr + 16, /* rights_inheriting */ BigInt(0), true);\n    }\n}\n\n/**\n * An exception that is thrown when the process exits.\n **/\nexport class WASIProcExit {\n    constructor(public readonly code: number) { }\n\n    /** @deprecated Use 'code' instead.\n     *  Has been renamed to have loose compatibility\n     *  with other implementations **/\n    get exitCode() { return this.code; }\n}", "import { WASIAbi } from \"../abi\";\nimport { WASIFeatureProvider, WASIOptions } from \"../options\";\n\n/**  \n * PreopenSpec represents a guest FS specification.  \n * In our design, preopens is simply a mapping of guest directory paths \n * that will be available to the guest.\n */\nexport type PreopenSpec = unknown; // Only keys matter\n\n/* ============================================================================\n   Stdio Support (fds 0, 1, 2)\n   ============================================================================ */\n\nexport interface FdEntry {\n    writev(iovs: Uint8Array[]): number;\n    readv(iovs: Uint8Array[]): number;\n    close(): void;\n}\n\nexport class WritableTextProxy implements FdEntry {\n    private decoder = new TextDecoder(\"utf-8\");\n    constructor(\n        private readonly handler: (lines: string | Uint8Array) => void,\n        private readonly outputBuffers: boolean\n    ) {\n        console.log(\"[WritableTextProxy] Created\");\n    }\n    writev(iovs: Uint8Array[]): number {\n        const totalBufferSize = iovs.reduce((acc, iov) => acc + iov.byteLength, 0);\n        let offset = 0;\n        const concatBuffer = new Uint8Array(totalBufferSize);\n        for (const buffer of iovs) {\n            concatBuffer.set(buffer, offset);\n            offset += buffer.byteLength;\n        }\n        if (this.outputBuffers) {\n            this.handler(concatBuffer);\n        } else {\n            this.handler(this.decoder.decode(concatBuffer));\n        }\n        return concatBuffer.length;\n    }\n    readv(_iovs: Uint8Array[]): number {\n        return 0;\n    }\n    close(): void { }\n}\n\nexport class ReadableTextProxy implements FdEntry {\n    private encoder = new TextEncoder();\n    private pending: Uint8Array | null = null;\n    constructor(private readonly consume: () => string | Uint8Array) {\n        console.log(\"[ReadableTextProxy] Created\");\n    }\n    writev(_iovs: Uint8Array[]): number {\n        return 0;\n    }\n    consumePending(pending: Uint8Array, requestLength: number): Uint8Array {\n        if (pending.byteLength < requestLength) {\n            this.pending = null;\n            return pending;\n        } else {\n            const result = pending.slice(0, requestLength);\n            this.pending = pending.slice(requestLength);\n            return result;\n        }\n    }\n    readv(iovs: Uint8Array[]): number {\n        let read = 0;\n        for (const buffer of iovs) {\n            let remaining = buffer.byteLength;\n            if (this.pending) {\n                const consumed = this.consumePending(this.pending, remaining);\n                buffer.set(consumed, 0);\n                remaining -= consumed.byteLength;\n                read += consumed.byteLength;\n            }\n            while (remaining > 0) {\n                const newData = this.consume();\n                let bytes: Uint8Array = (newData instanceof Uint8Array)\n                    ? newData : this.encoder.encode(newData);\n                if (bytes.length === 0) break;\n                if (bytes.length > remaining) {\n                    buffer.set(bytes.slice(0, remaining), buffer.byteLength - remaining);\n                    this.pending = bytes.slice(remaining);\n                    read += remaining;\n                    remaining = 0;\n                } else {\n                    buffer.set(bytes, buffer.byteLength - remaining);\n                    read += bytes.length;\n                    remaining -= bytes.length;\n                }\n            }\n        }\n        return read;\n    }\n    close(): void { }\n}\n\n/* ============================================================================\n   Memory File System Support\n   ============================================================================\n   - MemoryFS is built from a mapping (preopens) whose keys are guest directory paths.\n   - Files can later be added via addFile().\n   - Open file descriptors store the guest path so that repeated opens return the same FD.\n*/\n\ntype FSNode = DirectoryNode | FileNode | DevNullNode;\n\nexport interface DirectoryNode {\n    type: \"dir\";\n    entries: { [name: string]: FSNode; };\n}\n\nexport interface FileNode {\n    type: \"file\";\n    content: Uint8Array | Blob;\n}\n\nexport interface DevNullNode {\n    type: \"devnull\";\n}\n\nexport interface OpenFile {\n    node: FSNode;\n    position: number;\n    isPreopen?: boolean;\n    preopenPath?: string;\n    path: string;\n}\n\nexport class MemoryFS {\n    root: DirectoryNode;\n    preopenPaths: string[] = [];\n\n    constructor(preopens?: { [key: string]: PreopenSpec; }) {\n        this.root = { type: \"dir\", entries: {} };\n        this.ensureDir(\"/dev\");\n        this.setNode(\"/dev/null\", { type: \"devnull\" });\n        if (preopens) {\n            for (const dirPath in preopens) {\n                this.ensureDir(dirPath);\n                this.preopenPaths.push(dirPath);\n            }\n        }\n        if (this.preopenPaths.length === 0) {\n            this.ensureDir(\"/\");\n            this.preopenPaths.push(\"/\");\n        }\n    }\n\n    addFile(path: string, content: string | Blob | Uint8Array): void {\n        let data: Uint8Array | Blob;\n        if (typeof content === \"string\") {\n            data = new TextEncoder().encode(content);\n        } else {\n            data = content;\n        }\n        this.createFile(path, data);\n    }\n\n    ensureDir(path: string): DirectoryNode {\n        const parts = path.split(\"/\").filter(p => p.length > 0);\n        let current: DirectoryNode = this.root;\n        for (const part of parts) {\n            if (!current.entries[part]) {\n                current.entries[part] = { type: \"dir\", entries: {} };\n            }\n            const next = current.entries[part];\n            if (next.type !== \"dir\") throw new Error(`\"${part}\" is not a directory`);\n            current = next;\n        }\n        return current;\n    }\n\n    setNode(path: string, node: FSNode): void {\n        const parts = path.split(\"/\").filter(p => p.length > 0);\n        if (parts.length === 0) {\n            this.root = node as DirectoryNode;\n            return;\n        }\n        const fileName = parts.pop()!;\n        const dir = this.ensureDir(\"/\" + parts.join(\"/\"));\n        dir.entries[fileName] = node;\n    }\n\n    createFile(path: string, content: Uint8Array | Blob): FileNode {\n        const fileNode: FileNode = { type: \"file\", content };\n        this.setNode(path, fileNode);\n        return fileNode;\n    }\n\n    lookup(path: string): FSNode | null {\n        if (path === \"/\") return this.root;\n        const parts = path.split(\"/\").filter(p => p.length > 0);\n        let current: FSNode = this.root;\n        for (const part of parts) {\n            if (current.type !== \"dir\") return null;\n            current = current.entries[part];\n            if (!current) return null;\n        }\n        return current;\n    }\n\n    resolve(dir: DirectoryNode, relativePath: string): FSNode | null {\n        const parts = relativePath.split(\"/\").filter(p => p.length > 0);\n        let current: FSNode = dir;\n        for (const part of parts) {\n            if (part === \".\") continue;\n            if (part === \"..\") {\n                current = this.root;\n                continue;\n            }\n            if (current.type !== \"dir\") return null;\n            current = current.entries[part];\n            if (!current) return null;\n        }\n        return current;\n    }\n\n    createFileIn(dir: DirectoryNode, relativePath: string): FileNode {\n        const parts = relativePath.split(\"/\").filter(p => p.length > 0);\n        const fileName = parts.pop()!;\n        let current = dir;\n        for (const part of parts) {\n            if (!current.entries[part]) {\n                current.entries[part] = { type: \"dir\", entries: {} };\n            }\n            current = current.entries[part] as DirectoryNode;\n            if (current.type !== \"dir\") throw new Error(`\"${part}\" is not a directory`);\n        }\n        const fileNode: FileNode = { type: \"file\", content: new Uint8Array(0) };\n        current.entries[fileName] = fileNode;\n        return fileNode;\n    }\n\n    getDevNull(): FSNode {\n        const node = this.lookup(\"/dev/null\");\n        if (!node) throw new Error(\"/dev/null not found\");\n        return node;\n    }\n\n    getPreopenPaths(): string[] {\n        return this.preopenPaths;\n    }\n}\n\n/* ============================================================================\n   Combined WASI Provider: Stdio + Memory FS\n   ============================================================================\n   fds 0\u20132 are stdio; fds \u2265 3 come from our MemoryFS.\n   Repeated opens (by guest path) return the same FD.\n*/\n\nexport interface FDEntry {\n    fd: number;\n}\n\nexport interface OpenFileExtended extends OpenFile, FDEntry { }\n\nexport function useStdioAndFS(\n    options: {\n        memFs?: MemoryFS;\n        preopens?: { [key: string]: PreopenSpec; };\n        stdin?: () => string | Uint8Array;\n        stdout?: (lines: string | Uint8Array) => void;\n        stderr?: (lines: string | Uint8Array) => void;\n        outputBuffers?: boolean;\n    } = {}\n): WASIFeatureProvider {\n    return (wasiOptions: WASIOptions, abi: WASIAbi, memoryView: () => DataView) => {\n        // Minimal logging.\n        console.log(\"[useStdioAndFS] Initializing\");\n        const stdioFDs: FdEntry[] = [\n            new ReadableTextProxy(options.stdin || (() => \"\")),\n            new WritableTextProxy(options.stdout || console.log, options.outputBuffers || false),\n            new WritableTextProxy(options.stderr || console.error, options.outputBuffers || false),\n        ];\n        const fs = options.memFs || new MemoryFS(options.preopens);\n        const fsFDs: { [fd: number]: OpenFileExtended; } = {};\n        let nextFd = 3;\n        for (const preopenPath of fs.getPreopenPaths()) {\n            const node = fs.lookup(preopenPath);\n            if (node && node.type === \"dir\") {\n                fsFDs[nextFd] = {\n                    node,\n                    position: 0,\n                    isPreopen: true,\n                    preopenPath,\n                    path: preopenPath,\n                    fd: nextFd,\n                };\n                console.log(\"[useStdioAndFS] Preopened FD\", nextFd, \"->\", preopenPath);\n                nextFd++;\n            }\n        }\n        function getFdByPath(guestPath: string): OpenFileExtended | undefined {\n            for (const fd in fsFDs) {\n                if (fsFDs[fd].path === guestPath) return fsFDs[fd];\n            }\n            return undefined;\n        }\n        function getFD(\n            fd: number\n        ): { kind: \"stdio\"; entry: FdEntry; } | { kind: \"fs\"; openFile: OpenFileExtended; } | undefined {\n            if (fd < 3) return { kind: \"stdio\", entry: stdioFDs[fd] };\n            if (fsFDs[fd]) return { kind: \"fs\", openFile: fsFDs[fd] };\n            return undefined;\n        }\n        function getFSEntry(fd: number): OpenFileExtended | undefined {\n            return fsFDs[fd];\n        }\n        return {\n            fd_read: async (fd: number, iovs: number, iovsLen: number, nread: number) => {\n                console.log(\"[fd_read] Reading from FD\", fd);\n                const view = memoryView();\n                // Gather the WASI iovec buffers from guest memory.\n                const iovViews = abi.iovViews(view, iovs, iovsLen);\n                const entry = getFD(fd);\n                if (!entry) {\n                    console.log(\"[fd_read] Bad file descriptor\");\n                    return WASIAbi.WASI_ERRNO_BADF;\n                }\n\n                // For STDIN, use the corresponding handler.\n                if (entry.kind === \"stdio\") {\n                    console.log(\"[fd_read] Reading from STDIO\");\n                    const bytesRead = entry.entry.readv(iovViews);\n                    view.setUint32(nread, bytesRead, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n\n                // Directories and /dev/null: nothing to read.\n                if (entry.openFile.node.type === \"dir\") {\n                    return WASIAbi.WASI_ERRNO_ISDIR;\n                }\n                if (entry.openFile.node.type === \"devnull\") {\n                    view.setUint32(nread, 0, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n\n                const fileNode = entry.openFile.node as FileNode;\n                let totalRead = 0;\n\n                if (fileNode.content instanceof Blob) {\n                    console.log(\"[fd_read] Reading from Blob\");\n                    const blob = fileNode.content;\n                    // Process each iovec buffer one by one.\n                    for (const buf of iovViews) {\n                        // If we've reached the end of the blob, break out (EOF).\n                        console.log(\"[fd_read] Position:\", entry.openFile.position, \"Size:\", blob.size);\n                        if (entry.openFile.position >= blob.size) break;\n                        // Calculate how many bytes to read into this buffer.\n                        const bytesToRead = Math.min(buf.byteLength, blob.size - entry.openFile.position);\n                        console.log(\"[fd_read] Reading\", bytesToRead, \"bytes from\", entry.openFile.path);\n                        if (bytesToRead <= 0) break;\n                        // Slice and await the data for this chunk.\n                        const slice = blob.slice(entry.openFile.position, entry.openFile.position + bytesToRead);\n                        const arrayBuffer = await slice.arrayBuffer();\n                        console.log(\"[fd_read] Read\", arrayBuffer.byteLength, \"bytes from\", entry.openFile.path);\n                        const chunk = new Uint8Array(arrayBuffer);\n                        // Copy the chunk into the guest buffer.\n                        buf.set(chunk);\n                        totalRead += chunk.byteLength;\n                        entry.openFile.position += chunk.byteLength;\n                    }\n                } else {\n                    console.log(\"[fd_read] Reading from Uint8Array\");\n                    // Fallback for in-memory Uint8Array content.\n                    const data = fileNode.content as Uint8Array;\n                    const available = data.byteLength - entry.openFile.position;\n\n                    // Nothing to read if at EOF\n                    if (available <= 0) {\n                        view.setUint32(nread, 0, true);\n                        return WASIAbi.WASI_ESUCCESS;\n                    }\n\n                    // Process each iovec buffer\n                    for (const buf of iovViews) {\n                        if (totalRead >= available) break;\n\n                        const bytesToRead = Math.min(buf.byteLength, available - totalRead);\n                        if (bytesToRead <= 0) break;\n\n                        // Copy data from file content to the buffer\n                        const sourceStart = entry.openFile.position + totalRead;\n                        const chunk = data.subarray(sourceStart, sourceStart + bytesToRead);\n                        buf.set(chunk);\n                        totalRead += bytesToRead;\n                    }\n\n                    // Update position for Uint8Array case\n                    entry.openFile.position += totalRead;\n                }\n\n                // Write the total bytes read back to the WASM memory.\n                view.setUint32(nread, totalRead, true);\n                console.log(\"[fd_read] Read\", totalRead, \"bytes from\", entry.openFile.path);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_write: (fd: number, iovs: number, iovsLen: number, nwritten: number) => {\n                const view = memoryView();\n                const iovViews = abi.iovViews(view, iovs, iovsLen);\n                const entry = getFD(fd);\n                if (!entry) return WASIAbi.WASI_ERRNO_BADF;\n                let totalWritten = 0;\n                if (entry.kind === \"stdio\") {\n                    const bytesWritten = entry.entry.writev(iovViews);\n                    view.setUint32(nwritten, bytesWritten, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                } else {\n                    if (entry.openFile.node.type === \"dir\") return WASIAbi.WASI_ERRNO_ISDIR;\n                    if (entry.openFile.node.type === \"devnull\") {\n                        const total = iovViews.reduce((acc, buf) => acc + buf.byteLength, 0);\n                        view.setUint32(nwritten, total, true);\n                        return WASIAbi.WASI_ESUCCESS;\n                    }\n                    const fileNode = entry.openFile.node as FileNode;\n                    let pos = entry.openFile.position;\n                    const dataToWrite = iovViews.reduce((acc, buf) => acc + buf.byteLength, 0);\n                    const requiredLength = pos + dataToWrite;\n                    let newContent: Uint8Array;\n                    if (fileNode.content instanceof Blob) {\n                        // Cannot write to Blob, return error\n                        return WASIAbi.WASI_ERRNO_INVAL;\n                    }\n                    if (requiredLength > fileNode.content.byteLength) {\n                        newContent = new Uint8Array(requiredLength);\n                        newContent.set(fileNode.content, 0);\n                    } else {\n                        newContent = fileNode.content;\n                    }\n                    for (const buf of iovViews) {\n                        newContent.set(buf, pos);\n                        pos += buf.byteLength;\n                        totalWritten += buf.byteLength;\n                    }\n                    fileNode.content = newContent;\n                    entry.openFile.position = pos;\n                    view.setUint32(nwritten, totalWritten, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n            },\n\n            fd_close: (fd: number) => {\n                if (fd < 3) {\n                    stdioFDs[fd].close();\n                    return WASIAbi.WASI_ESUCCESS;\n                } else {\n                    if (fsFDs[fd] === undefined) return WASIAbi.WASI_ERRNO_BADF;\n                    delete fsFDs[fd];\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n            },\n\n            fd_seek: (fd: number, offset: bigint, whence: number, newOffset: number) => {\n                const view = memoryView();\n                if (fd < 3) return WASIAbi.WASI_ERRNO_BADF;\n                const openFile = getFSEntry(fd);\n                if (!openFile || openFile.node.type !== \"file\") return WASIAbi.WASI_ERRNO_BADF;\n                let pos = openFile.position;\n                const fileLength = openFile.node.content instanceof Blob\n                    ? openFile.node.content.size\n                    : openFile.node.content.byteLength;\n                switch (whence) {\n                    case 0: pos = Number(offset); break;\n                    case 1: pos = pos + Number(offset); break;\n                    case 2: pos = fileLength + Number(offset); break;\n                    default: return WASIAbi.WASI_ERRNO_INVAL;\n                }\n                if (pos < 0) pos = 0;\n                openFile.position = pos;\n                view.setUint32(newOffset, pos, true);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_tell: (fd: number, offset_ptr: number) => {\n                const view = memoryView();\n                if (fd < 3) return WASIAbi.WASI_ERRNO_BADF;\n                const openFile = getFSEntry(fd);\n\n                if (!openFile) return WASIAbi.WASI_ERRNO_BADF;\n                view.setBigUint64(offset_ptr, BigInt(openFile.position), true);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_fdstat_get: (fd: number, buf: number) => {\n                const view = memoryView();\n                const entry = getFD(fd);\n                if (!entry) return WASIAbi.WASI_ERRNO_BADF;\n                let filetype: number;\n                if (entry.kind === \"stdio\") {\n                    filetype = WASIAbi.WASI_FILETYPE_CHARACTER_DEVICE;\n                } else {\n                    filetype = (entry.openFile.node.type === \"dir\")\n                        ? WASIAbi.WASI_FILETYPE_DIRECTORY\n                        : (entry.openFile.node.type === \"devnull\")\n                            ? WASIAbi.WASI_FILETYPE_CHARACTER_DEVICE\n                            : WASIAbi.WASI_FILETYPE_REGULARFILE;\n                }\n                abi.writeFdstat(view, buf, filetype, 0);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_filestat_get: (fd: number, buf: number) => {\n                const view = memoryView();\n                const entry = getFD(fd);\n                if (!entry) return WASIAbi.WASI_ERRNO_BADF;\n                let filetype: number;\n                let size = 0;\n                if (entry.kind === \"stdio\") {\n                    filetype = WASIAbi.WASI_FILETYPE_CHARACTER_DEVICE;\n                } else {\n                    if (entry.openFile.node.type === \"dir\") {\n                        filetype = WASIAbi.WASI_FILETYPE_DIRECTORY;\n                    } else if (entry.openFile.node.type === \"devnull\") {\n                        filetype = WASIAbi.WASI_FILETYPE_CHARACTER_DEVICE;\n                    } else {\n                        filetype = WASIAbi.WASI_FILETYPE_REGULARFILE;\n                        size = entry.openFile.node.content instanceof Blob\n                            ? entry.openFile.node.content.size\n                            : entry.openFile.node.content.byteLength;\n                    }\n                }\n                abi.writeFilestat(view, buf, filetype);\n                view.setBigUint64(buf + 32, BigInt(size), true);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_prestat_get: (fd: number, buf: number) => {\n                const view = memoryView();\n                if (fd < 3) return WASIAbi.WASI_ERRNO_BADF;\n                const openFile = getFSEntry(fd);\n                if (!openFile || !openFile.isPreopen) return WASIAbi.WASI_ERRNO_BADF;\n                view.setUint8(buf, 0);\n                const pathStr = openFile.preopenPath || \"\";\n                view.setUint32(buf + 4, pathStr.length, true);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            fd_prestat_dir_name: (fd: number, pathPtr: number, pathLen: number) => {\n                if (fd < 3) return WASIAbi.WASI_ERRNO_BADF;\n                const openFile = getFSEntry(fd);\n                if (!openFile || !openFile.isPreopen) return WASIAbi.WASI_ERRNO_BADF;\n                const pathStr = openFile.preopenPath || \"\";\n                if (pathStr.length !== pathLen) return WASIAbi.WASI_ERRNO_INVAL;\n                const view = memoryView();\n                for (let i = 0; i < pathStr.length; i++) {\n                    view.setUint8(pathPtr + i, pathStr.charCodeAt(i));\n                }\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            // proc_exit: minimal implementation\n            proc_exit: (exit_code: number) => {\n                console.log(\"[proc_exit] Exiting with code:\", exit_code);\n                throw new Error(\"proc_exit called with code: \" + exit_code);\n            },\n\n            // fd_open (legacy interface)\n            fd_open: (\n                dirfd: number,\n                pathPtr: number,\n                pathLen: number,\n                oflags: number,\n                _fs_rights_base: bigint,\n                _fs_rights_inheriting: bigint,\n                _fdflags: number,\n                opened_fd: number\n            ) => {\n                const view = memoryView();\n                let path = \"\";\n                for (let i = 0; i < pathLen; i++) {\n                    path += String.fromCharCode(view.getUint8(pathPtr + i));\n                }\n                if (dirfd < 3) return WASIAbi.WASI_ERRNO_NOTDIR;\n                const dirEntry = getFSEntry(dirfd);\n                if (!dirEntry || dirEntry.node.type !== \"dir\") return WASIAbi.WASI_ERRNO_NOTDIR;\n                const guestPath = (dirEntry.path.endsWith(\"/\") ? dirEntry.path : dirEntry.path + \"/\") + path;\n                const existing = getFdByPath(guestPath);\n                if (existing) {\n                    view.setUint32(opened_fd, existing.fd, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n                let target = fs.resolve(dirEntry.node as DirectoryNode, path);\n                const O_CREAT = 1 << 0, O_EXCL = 1 << 1, O_TRUNC = 1 << 2;\n                if (target) {\n                    if (oflags & O_EXCL) return WASIAbi.WASI_ERRNO_EXIST;\n                    if (oflags & O_TRUNC) {\n                        if (target.type !== \"file\") return WASIAbi.WASI_ERRNO_INVAL;\n                        (target as FileNode).content = new Uint8Array(0);\n                    }\n                } else {\n                    if (!(oflags & O_CREAT)) return WASIAbi.WASI_ERRNO_NOENT;\n                    target = fs.createFileIn(dirEntry.node as DirectoryNode, path);\n                }\n                fsFDs[nextFd] = {\n                    node: target,\n                    position: 0,\n                    isPreopen: false,\n                    path: guestPath,\n                    fd: nextFd,\n                };\n                view.setUint32(opened_fd, nextFd, true);\n                nextFd++;\n                return WASIAbi.WASI_ESUCCESS;\n            },\n\n            // path_open implementation\n            path_open: (\n                dirfd: number,\n                _dirflags: number,\n                pathPtr: number,\n                pathLen: number,\n                oflags: number,\n                _fs_rights_base: bigint,\n                _fs_rights_inheriting: bigint,\n                _fdflags: number,\n                opened_fd: number\n            ) => {\n                const view = memoryView();\n                let path = \"\";\n                for (let i = 0; i < pathLen; i++) {\n                    path += String.fromCharCode(view.getUint8(pathPtr + i));\n                }\n                if (dirfd < 3) return WASIAbi.WASI_ERRNO_NOTDIR;\n                const dirEntry = getFSEntry(dirfd);\n                if (!dirEntry || dirEntry.node.type !== \"dir\") return WASIAbi.WASI_ERRNO_NOTDIR;\n                const guestPath = (dirEntry.path.endsWith(\"/\") ? dirEntry.path : dirEntry.path + \"/\") + path;\n                const existing = getFdByPath(guestPath);\n                if (existing) {\n                    view.setUint32(opened_fd, existing.fd, true);\n                    return WASIAbi.WASI_ESUCCESS;\n                }\n                let target = fs.resolve(dirEntry.node as DirectoryNode, path);\n                const O_CREAT = 1 << 0, O_EXCL = 1 << 1, O_TRUNC = 1 << 2;\n                if (target) {\n                    if (oflags & O_EXCL) return WASIAbi.WASI_ERRNO_EXIST;\n                    if (oflags & O_TRUNC) {\n                        if (target.type !== \"file\") return WASIAbi.WASI_ERRNO_INVAL;\n                        (target as FileNode).content = new Uint8Array(0);\n                    }\n                } else {\n                    if (!(oflags & O_CREAT)) return WASIAbi.WASI_ERRNO_NOENT;\n                    target = fs.createFileIn(dirEntry.node as DirectoryNode, path);\n                }\n                fsFDs[nextFd] = {\n                    node: target,\n                    position: 0,\n                    isPreopen: false,\n                    path: guestPath,\n                    fd: nextFd,\n                };\n                view.setUint32(opened_fd, nextFd, true);\n                nextFd++;\n                return WASIAbi.WASI_ESUCCESS;\n            },\n            path_filestat_get: (fd: number, flags: number, pathPtr: number, pathLen: number, buf: number) => {\n                const view = memoryView();\n                // Read the relative path from WASM memory.\n                let guestRelPath = \"\";\n                for (let i = 0; i < pathLen; i++) {\n                    guestRelPath += String.fromCharCode(view.getUint8(pathPtr + i));\n                }\n                // Get the base FD entry; it must be a directory.\n                const baseEntry = getFD(fd);\n                if (!baseEntry) return WASIAbi.WASI_ERRNO_BADF;\n                if (baseEntry.kind === \"stdio\" || baseEntry.openFile.node.type !== \"dir\") {\n                    return WASIAbi.WASI_ERRNO_NOTDIR;\n                }\n                // Compute the full guest path.\n                const basePath = baseEntry.openFile.path;\n                const fullGuestPath = basePath.endsWith(\"/\") ? basePath + guestRelPath : basePath + \"/\" + guestRelPath;\n                // Lookup the node in the MemoryFS.\n                const node = fs.lookup(fullGuestPath);\n                if (!node) return WASIAbi.WASI_ERRNO_NOENT;\n                // Determine file type and size.\n                let filetype: number;\n                let size = 0;\n                if (node.type === \"dir\") {\n                    filetype = WASIAbi.WASI_FILETYPE_DIRECTORY;\n                } else if (node.type === \"devnull\") {\n                    filetype = WASIAbi.WASI_FILETYPE_CHARACTER_DEVICE;\n                } else {\n                    filetype = WASIAbi.WASI_FILETYPE_REGULARFILE;\n                    const fileNode = node as FileNode;\n                    size = fileNode.content instanceof Blob\n                        ? fileNode.content.size\n                        : fileNode.content.byteLength;\n                }\n                // Write out the filestat structure.\n                abi.writeFilestat(view, buf, filetype);\n                view.setBigUint64(buf + 32, BigInt(size), true);\n                return WASIAbi.WASI_ESUCCESS;\n            }\n        };\n    };\n}", "import { WASIAbi } from \"../abi\";\nimport { WASIOptions } from \"../options\";\n\n/**\n * A feature provider that provides `args_get` and `args_sizes_get`\n */\nexport function useArgs(options: WASIOptions, abi: WASIAbi, memoryView: () => DataView): WebAssembly.ModuleImports {\n    const args = options.args || [];\n    return {\n        args_get: (argv: number, argvBuf: number) => {\n            let offsetOffset = argv;\n            let bufferOffset = argvBuf;\n            const view = memoryView();\n            for (const arg of args) {\n                view.setUint32(offsetOffset, bufferOffset, true);\n                offsetOffset += 4;\n                bufferOffset += abi.writeString(view, `${arg}\\0`, bufferOffset);\n            }\n            return WASIAbi.WASI_ESUCCESS;\n        },\n        args_sizes_get: (argc: number, argvBufSize: number) => {\n            const view = memoryView();\n            view.setUint32(argc, args.length, true);\n            const bufferSize = args.reduce((acc, arg) => acc + abi.byteLength(arg) + 1, 0);\n            view.setUint32(argvBufSize, bufferSize, true);\n            return WASIAbi.WASI_ESUCCESS;\n        },\n    };\n}", "import { WASIAbi } from \"../abi\";\nimport { WASIOptions } from \"../options\";\n\n/**\n * A feature provider that provides `clock_res_get` and `clock_time_get` by JavaScript's Date.\n */\nexport function useClock(options: WASIOptions, abi: WASIAbi, memoryView: () => DataView): WebAssembly.ModuleImports {\n    return {\n        clock_res_get: (clockId: number, resolution: number) => {\n            let resolutionValue: number;\n            switch (clockId) {\n                case WASIAbi.WASI_CLOCK_MONOTONIC: {\n                    // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now\n                    resolutionValue = 5000;\n                    break;\n                }\n                case WASIAbi.WASI_CLOCK_REALTIME: {\n                    resolutionValue = 1000;\n                    break;\n                }\n                default: return WASIAbi.WASI_ENOSYS;\n            }\n            const view = memoryView();\n            // 64-bit integer, but only the lower 32 bits are used.\n            view.setUint32(resolution, resolutionValue, true);\n            return WASIAbi.WASI_ESUCCESS;\n        },\n        clock_time_get: (clockId: number, precision: number, time: number) => {\n            let nowMs: number = 0;\n            switch (clockId) {\n                case WASIAbi.WASI_CLOCK_MONOTONIC: {\n                    nowMs = performance.now();\n                    break;\n                }\n                case WASIAbi.WASI_CLOCK_REALTIME: {\n                    nowMs = Date.now();\n                    break;\n                }\n                default: return WASIAbi.WASI_ENOSYS;\n            }\n            const view = memoryView();\n            if (BigInt) {\n                const msToNs = (ms: number) => {\n                    const msInt = Math.trunc(ms);\n                    const decimal = BigInt(Math.round((ms - msInt) * 1_000_000));\n                    const ns = BigInt(msInt) * BigInt(1_000_000);\n                    return ns + decimal;\n                };\n                const now = BigInt(msToNs(nowMs));\n                view.setBigUint64(time, now, true);\n            } else {\n                // Fallback to two 32-bit numbers losing precision\n                const now = Date.now() * 1_000_000;\n                view.setUint32(time, now & 0x0000ffff, true);\n                view.setUint32(time + 4, now & 0xffff0000, true);\n            }\n            return WASIAbi.WASI_ESUCCESS;\n        },\n    };\n}", "import { WASIAbi } from \"../abi\";\nimport { WASIOptions } from \"../options\";\n\n/**\n * A feature provider that provides `environ_get` and `environ_sizes_get`\n */\nexport function useEnviron(options: WASIOptions, abi: WASIAbi, memoryView: () => DataView): WebAssembly.ModuleImports {\n\n    return {\n        environ_get: (environ: number, environBuf: number) => {\n            let offsetOffset = environ;\n            let bufferOffset = environBuf;\n            const view = memoryView();\n            for (const key in options.env) {\n                const value = options.env[key];\n                view.setUint32(offsetOffset, bufferOffset, true);\n                offsetOffset += 4;\n                bufferOffset += abi.writeString(view, `${key}=${value}\\0`, bufferOffset);\n            }\n            return WASIAbi.WASI_ESUCCESS;\n        },\n        environ_sizes_get: (environ: number, environBufSize: number) => {\n            const view = memoryView();\n            view.setUint32(environ, Object.keys(options.env || {}).length, true);\n            view.setUint32(\n                environBufSize,\n                Object.entries(options.env || {}).reduce(\n                    (acc, [key, value]) => {\n                        return acc + abi.byteLength(key) /* = */ + 1 + abi.byteLength(value) /* \\0 */ + 1;\n                    },\n                    0\n                ),\n                true\n            );\n            return WASIAbi.WASI_ESUCCESS;\n        }\n    };\n}", "import { WASIAbi } from \"../abi\";\nimport { WASIFeatureProvider } from \"../options\";\n\n/**\n * Create a feature provider that provides `random_get` with `crypto` APIs as backend by default.\n */\nexport function useRandom(\n    useOptions: {\n        randomFillSync?: (buffer: Uint8Array) => void,\n    } = {}\n): WASIFeatureProvider {\n    return (options, abi, memoryView) => {\n        return {\n            random_get: (bufferOffset: number, length: number) => {\n                const view = memoryView();\n\n                const buffer = new Uint8Array(view.buffer, bufferOffset, length);\n                crypto.getRandomValues(buffer);\n                return WASIAbi.WASI_ESUCCESS;\n            },\n        };\n    };\n}", "import { WASIAbi, WASIProcExit } from \"./abi\";\nexport { WASIProcExit } from \"./abi\";\nimport { WASIOptions } from \"./options\";\n\nexport * from \"./features/args\";\nexport * from \"./features/clock\";\nexport * from \"./features/environ\";\nexport { useStdioAndFS } from \"./features/fd\";\nexport * from \"./features/random\";\n\n\nexport class WASI {\n    /**\n     * `wasiImport` is an object that implements the WASI system call API. This object\n     * should be passed as the `wasi_snapshot_preview1` import during the instantiation\n     * of a [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance).\n     */\n    readonly wasiImport: WebAssembly.ModuleImports;\n    private instance: WebAssembly.Instance | null = null;\n    private isStarted: boolean = false;\n\n    constructor(options?: WASIOptions) {\n        this.wasiImport = {};\n        const abi = new WASIAbi();\n        if (options && options.features) {\n            for (const useFeature of options.features) {\n                const imports = useFeature(options, abi, this.view.bind(this));\n                this.wasiImport = { ...this.wasiImport, ...imports };\n            }\n        }\n        // Provide default implementations for missing functions just returning ENOSYS.\n        for (const key of WASIAbi.IMPORT_FUNCTIONS) {\n            if (!(key in this.wasiImport)) {\n                this.wasiImport[key] = () => { \n                    console.log(\"trying to call unimpleted function\", key);\n                    return WASIAbi.WASI_ENOSYS; };\n            }\n        }\n    }\n\n    private view(): DataView {\n        if (!this.instance) {\n            throw new Error('wasi.start() or wasi.initialize() has not been called');\n        }\n        if (!this.instance.exports.memory) {\n            throw new Error('instance.exports.memory is undefined');\n        }\n        if (!(this.instance.exports.memory instanceof WebAssembly.Memory)) {\n            throw new Error('instance.exports.memory is not a WebAssembly.Memory');\n        }\n        return new DataView(this.instance.exports.memory.buffer);\n    }\n\n    /**\n     * Attempt to begin execution of `instance` as a WASI command by invoking its`_start()` export. If `instance` does not contain a `_start()` export, or if`instance` contains an `_initialize()`\n     * export, then an exception is thrown.\n     *\n     * `start()` requires that `instance` exports a [`WebAssembly.Memory`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory) named`memory`. If\n     * `instance` does not have a `memory` export an exception is thrown.\n     *\n     * If `start()` is called more than once, an exception is thrown.\n     */\n    async start(instance: WebAssembly.Instance): Promise<number> {\n        if (this.isStarted) {\n            throw new Error('wasi.start() or wasi.initialize() has already been called');\n        }\n        this.isStarted = true;\n        this.instance = instance;\n        if (!this.instance.exports._start) {\n            throw new Error('instance.exports._start is undefined');\n        }\n        if (typeof this.instance.exports._start !== 'function') {\n            throw new Error('instance.exports._start is not a function');\n        }\n        try {\n            console.log(this.instance.exports);\n            await this.instance.exports._start();\n            return WASIAbi.WASI_ESUCCESS;\n        } catch (e) {\n            if (e instanceof WASIProcExit) {\n                return e.code;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempt to initialize `instance` as a WASI reactor by invoking its`_initialize()` export, if it is present. If `instance` contains a `_start()`export, then an exception is thrown.\n     *\n     * `initialize()` requires that `instance` exports a [`WebAssembly.Memory`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory) named`memory`.\n     * If `instance` does not have a `memory` export an exception is thrown.\n     *\n     * If `initialize()` is called more than once, an exception is thrown.\n     */\n    initialize(instance: WebAssembly.Instance): void {\n        if (this.isStarted) {\n            throw new Error('wasi.start() or wasi.initialize() has already been called');\n        }\n        this.isStarted = true;\n        this.instance = instance;\n        if (!this.instance.exports._initialize) {\n            throw new Error('instance.exports._initialize is undefined');\n        }\n        if (typeof this.instance.exports._initialize !== 'function') {\n            throw new Error('instance.exports._initialize is not a function');\n        }\n        this.instance.exports._initialize();\n    }\n}", "const t = new WeakMap; function e(t, e) { return new Proxy(t, { get: (t, r) => e(t[r]) }); } class r { constructor() { this.value = void 0, this.exports = null; } getState() { return this.exports.asyncify_get_state(); } assertNoneState() { let t = this.getState(); if (0 !== t) throw new Error(`Invalid async state ${t}, expected 0.`); } wrapImportFn(t) { return (...e) => { if (2 === this.getState()) return this.exports.asyncify_stop_rewind(), this.value; this.assertNoneState(); let r = t(...e); if (!(s = r) || \"object\" != typeof s && \"function\" != typeof s || \"function\" != typeof s.then) return r; var s; this.exports.asyncify_start_unwind(16), this.value = r; }; } wrapModuleImports(t) { return e(t, t => \"function\" == typeof t ? this.wrapImportFn(t) : t); } wrapImports(t) { if (void 0 !== t) return e(t, (t = Object.create(null)) => this.wrapModuleImports(t)); } wrapExportFn(e) { let r = t.get(e); return void 0 !== r || (r = async (...t) => { this.assertNoneState(); let r = e(...t); for (; 1 === this.getState();)this.exports.asyncify_stop_unwind(), this.value = await this.value, this.assertNoneState(), this.exports.asyncify_start_rewind(16), r = e(); return this.assertNoneState(), r; }, t.set(e, r)), r; } wrapExports(e) { let r = Object.create(null); for (let t in e) { let s = e[t]; \"function\" != typeof s || t.startsWith(\"asyncify_\") || (s = this.wrapExportFn(s)), Object.defineProperty(r, t, { enumerable: !0, value: s }); } return t.set(e, r), r; } init(t, e) { const { exports: r } = t, n = r.memory || e.env && e.env.memory; new Int32Array(n.buffer, 16).set([24, 8388608]), this.exports = this.wrapExports(r), Object.setPrototypeOf(t, s.prototype); } } class s extends WebAssembly.Instance { constructor(t, e) { let s = new r; super(t, s.wrapImports(e)), s.init(this, e); } get exports() { return t.get(super.exports); } } async function n(t, e) { let s = new r, n = await WebAssembly.instantiate(t, s.wrapImports(e)); return s.init(n instanceof WebAssembly.Instance ? n : n.instance, e), n; } async function a(t, e) { let s = new r, n = await WebAssembly.instantiateStreaming(t, s.wrapImports(e)); return s.init(n.instance, e), n; } Object.defineProperty(s.prototype, \"exports\", { enumerable: !0 }); export { s as Instance, n as instantiate, a as instantiateStreaming };\n", "// src/index.ts\n\n\nimport exiftool from './ex'\nimport { MemoryFS, useStdioAndFS } from \"./wasi/features/fd\";\n\n\nimport { useArgs, useClock, useEnviron, useRandom, WASI } from './wasi';\nimport { instantiateStreaming } from 'asyncify-wasm';\n/**\n * A simple function that greets a person.\n */\nexport function hello(name: string): string {\n    return `Hello, ${name}!`;\n}\n\n/**\n * Instantiates a WASM module using WASI, with the provided file Blob preopened\n * at `/input.txt` in the in-memory file system.\n *\n * @param file - A Blob (for example, a user-selected file) that will be made available to the WASM module.\n */\nexport async function runWasmModuleWithFile(file: File): Promise<void> {\n    console.log(\"Running WASM module with file\", file);\n\n    const mem = new MemoryFS({\n        '/': true,\n    })\n\n    mem.addFile(`/${file.name}`, file);\n   \n   const wasi = new WASI({\n       args: ['example', `/${file.name}`],\n        features: [\n            useEnviron,\n            useArgs,\n            useRandom(),\n            useClock,\n            useStdioAndFS({\n                memFs: mem,\n                stdout: (str) => {\n                    console.log(str);\n                    // Append output to an element with id 'output'\n                    const outputElem = document.getElementById('output');\n                    if (outputElem) {\n                        outputElem.innerHTML += `<p>${str}</p>`;\n                    }\n                },\n                stderr: (str) => {\n                    console.error(str);\n                    const outputElem = document.getElementById('output');\n                    if (outputElem) {\n                        outputElem.innerHTML += `<p style=\"color:red;\">${str}</p>`;\n                    }\n                },\n            }),\n        ]\n    });\n\n\n    // Fetch and instantiate the WASM module.\n    // (Ensure that your WASM module is built to use the WASI syscalls and read from /input.txt.)\n\n    const { instance } = await instantiateStreaming(fetch('example.wasm'), {\n        wasi_snapshot_preview1: wasi.wasiImport,\n    });\n\n    const exitCode = await wasi.start(instance)\n   alert(exitCode)\n}\n"],
  "mappings": "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",
  "names": ["e", "t", "e", "r", "s", "t", "e", "s"]
}
